"""Route analysis and context building for LLM processing."""

from datetime import datetime
from planner.schemas import (
    RouteSegment,
    WeatherForecast,
    RoutePreferences,
    Location,
)


class RouteAnalyzer:
    """Analyzes route data and builds context for Claude LLM."""

    def build_context(
        self,
        origin: Location,
        destination: Location,
        segments: list[RouteSegment],
        weather_forecasts: list[WeatherForecast],
        elevation_profile: list[float],
        preferences: RoutePreferences,
        warnings: list[str],
        recommended_gear: list[str],
    ) -> str:
        """Build comprehensive context for Claude to analyze the route.

        Args:
            origin: Starting location.
            destination: Ending location.
            segments: Route segments.
            weather_forecasts: Weather forecasts along the route.
            elevation_profile: Elevation data for the route.
            preferences: User preferences.
            warnings: Any warnings generated by risk assessment.
            recommended_gear: Recommended gear list.

        Returns:
            Formatted context string for Claude.
        """
        # Calculate route summary
        total_distance = sum(seg.distance_km for seg in segments)
        total_elevation_gain = sum(seg.elevation_gain_m for seg in segments)
        total_elevation_loss = sum(seg.elevation_loss_m for seg in segments)
        total_duration = sum(seg.estimated_duration_min for seg in segments)

        # Build context sections
        sections = [
            self._build_route_summary(
                origin,
                destination,
                total_distance,
                total_elevation_gain,
                total_elevation_loss,
                total_duration,
            ),
            self._build_preferences_summary(preferences),
            self._build_elevation_analysis(elevation_profile, segments),
            self._build_weather_summary(weather_forecasts),
            self._build_segments_detail(segments),
            self._build_warnings_and_gear(warnings, recommended_gear),
            self._build_analysis_prompt(),
        ]

        return "\n\n".join(sections)

    def _build_route_summary(
        self,
        origin: Location,
        destination: Location,
        total_distance: float,
        total_elevation_gain: float,
        total_elevation_loss: float,
        total_duration: int,
    ) -> str:
        """Build route summary section.

        Args:
            origin: Starting location.
            destination: Ending location.
            total_distance: Total distance in km.
            total_elevation_gain: Total elevation gain in meters.
            total_elevation_loss: Total elevation loss in meters.
            total_duration: Total estimated duration in minutes.

        Returns:
            Formatted summary string.
        """
        origin_name = origin.name or f"{origin.lat:.3f}, {origin.lng:.3f}"
        dest_name = destination.name or f"{destination.lat:.3f}, {destination.lng:.3f}"

        return f"""# Route Overview

**From:** {origin_name}
**To:** {dest_name}
**Total Distance:** {total_distance:.1f} km
**Total Elevation Gain:** {total_elevation_gain:.0f} m
**Total Elevation Loss:** {total_elevation_loss:.0f} m
**Estimated Duration:** {total_duration // 60}h {total_duration % 60}m"""

    def _build_preferences_summary(self, preferences: RoutePreferences) -> str:
        """Build preferences summary section.

        Args:
            preferences: User route preferences.

        Returns:
            Formatted preferences string.
        """
        prefs = [
            f"**Difficulty Level:** {preferences.difficulty}",
            f"**Avoid Traffic:** {'Yes' if preferences.avoid_traffic else 'No'}",
            f"**Prefer Scenic Routes:** {'Yes' if preferences.prefer_scenic else 'No'}",
        ]

        if preferences.max_distance_km:
            prefs.append(f"**Max Distance:** {preferences.max_distance_km} km")
        if preferences.max_elevation_gain_m:
            prefs.append(
                f"**Max Elevation Gain:** {preferences.max_elevation_gain_m} m"
            )

        return "# User Preferences\n\n" + "\n".join(prefs)

    def _build_elevation_analysis(
        self, elevation_profile: list[float], segments: list[RouteSegment]
    ) -> str:
        """Build elevation analysis section.

        Args:
            elevation_profile: List of elevation values.
            segments: Route segments.

        Returns:
            Formatted elevation analysis.
        """
        if not elevation_profile:
            return "# Elevation Profile\n\nNo elevation data available."

        min_elev = min(elevation_profile)
        max_elev = max(elevation_profile)
        avg_elev = sum(elevation_profile) / len(elevation_profile)

        # Calculate steepest sections
        max_climb_rate = 0.0
        steepest_idx = 0

        for i, seg in enumerate(segments):
            if seg.distance_km > 0:
                climb_rate = seg.elevation_gain_m / (seg.distance_km * 1000)
                if climb_rate > max_climb_rate:
                    max_climb_rate = climb_rate
                    steepest_idx = i

        return f"""# Elevation Profile

**Minimum Elevation:** {min_elev:.0f} m
**Maximum Elevation:** {max_elev:.0f} m
**Average Elevation:** {avg_elev:.0f} m
**Elevation Range:** {max_elev - min_elev:.0f} m
**Steepest Climb:** {max_climb_rate * 100:.1f}% gradient in segment {steepest_idx + 1}"""

    def _build_weather_summary(self, forecasts: list[WeatherForecast]) -> str:
        """Build weather summary section.

        Args:
            forecasts: Weather forecasts.

        Returns:
            Formatted weather summary.
        """
        if not forecasts:
            return "# Weather Forecast\n\nNo weather data available."

        # Calculate weather statistics
        avg_temp = sum(f.temperature for f in forecasts) / len(forecasts)
        max_wind = max(f.wind_speed for f in forecasts)
        avg_precip = sum(f.precipitation_probability for f in forecasts) / len(
            forecasts
        )

        # Identify weather changes
        weather_changes = []
        prev_code = None
        for f in forecasts:
            if f.weather_code != prev_code:
                time_str = f.time.strftime("%H:%M")
                weather_changes.append(f"- {time_str}: {f.description}")
                prev_code = f.weather_code

        changes_text = "\n".join(weather_changes[:5])  # Show first 5 changes

        return f"""# Weather Forecast

**Average Temperature:** {avg_temp:.1f}Â°C
**Maximum Wind Speed:** {max_wind:.1f} m/s
**Average Precipitation Probability:** {avg_precip:.0f}%

**Expected Conditions:**
{changes_text}"""

    def _build_segments_detail(self, segments: list[RouteSegment]) -> str:
        """Build detailed segment information.

        Args:
            segments: Route segments.

        Returns:
            Formatted segment details.
        """
        segment_lines = []
        for i, seg in enumerate(segments):
            segment_lines.append(
                f"{i + 1}. **{seg.distance_km:.1f} km** - "
                f"{seg.surface_type} surface, "
                f"+{seg.elevation_gain_m:.0f}m/-{seg.elevation_loss_m:.0f}m, "
                f"~{seg.estimated_duration_min}min"
            )

        segments_text = "\n".join(segment_lines)
        return f"""# Route Segments

{segments_text}"""

    def _build_warnings_and_gear(
        self, warnings: list[str], recommended_gear: list[str]
    ) -> str:
        """Build warnings and gear recommendations.

        Args:
            warnings: List of warnings.
            recommended_gear: List of recommended gear.

        Returns:
            Formatted warnings and gear section.
        """
        warnings_text = "\n".join(f"- {w}" for w in warnings) if warnings else "None"
        gear_text = (
            "\n".join(f"- {g}" for g in recommended_gear)
            if recommended_gear
            else "Standard cycling gear"
        )

        return f"""# Warnings

{warnings_text}

# Recommended Gear

{gear_text}"""

    def _build_analysis_prompt(self) -> str:
        """Build the prompt for Claude to analyze the route.

        Returns:
            Analysis prompt string.
        """
        return """# Analysis Request

Based on the route data above, please provide:

1. **Overall Assessment**: Is this route suitable for the requested difficulty level and preferences?
2. **Highlights**: What are the best parts of this route? (scenic views, interesting landmarks, etc.)
3. **Challenges**: What difficulties should the cyclist expect? (steep climbs, weather concerns, etc.)
4. **Timing Recommendations**: When during the day is best to start, considering weather and elevation?
5. **Safety Considerations**: Any safety concerns or precautions to take?
6. **Alternative Suggestions**: If the route doesn't match preferences well, suggest modifications.

Please provide practical, actionable advice for a cyclist planning to ride this route."""

    def summarize_route_stats(self, segments: list[RouteSegment]) -> dict:
        """Summarize route statistics for programmatic use.

        Args:
            segments: Route segments.

        Returns:
            Dictionary of route statistics.
        """
        total_distance = sum(seg.distance_km for seg in segments)
        total_elevation_gain = sum(seg.elevation_gain_m for seg in segments)
        total_elevation_loss = sum(seg.elevation_loss_m for seg in segments)
        total_duration = sum(seg.estimated_duration_min for seg in segments)

        # Calculate surface type distribution
        surface_km = {}
        for seg in segments:
            surface_km[seg.surface_type] = (
                surface_km.get(seg.surface_type, 0) + seg.distance_km
            )

        return {
            "total_distance_km": total_distance,
            "total_elevation_gain_m": total_elevation_gain,
            "total_elevation_loss_m": total_elevation_loss,
            "total_duration_min": total_duration,
            "surface_distribution": surface_km,
            "num_segments": len(segments),
        }
